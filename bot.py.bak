import os
import threading
import uuid
import logging
import asyncio
from flask import Flask, request, jsonify, render_template_string
from telegram import Update, LabeledPrice, InlineKeyboardButton, InlineKeyboardMarkup
from telegram.request import HTTPXRequest
from telegram.error import NetworkError
from telegram.ext import Application, CommandHandler, ContextTypes, CallbackQueryHandler, PreCheckoutQueryHandler, MessageHandler, filters

import config
import database as db
from payments import generate_payment_link
from webhook_validator import WebhookValidator, validate_webhook_data
from bridge import bridge_task, send_payment_notification

# Configure logging
config.setup_logging()
logger = logging.getLogger(__name__)

# Initialize Flask
app = Flask(__name__)

# --- Webhook Routes ---
@app.route(f'/webhook/oxapay/{config.WEBHOOK_SECRET}', methods=['POST'])
def webhook_oxapay():
    """Webhook seguro para OxaPay con validaci√≥n HMAC-SHA256"""
    data = request.json
    signature = request.headers.get('X-OxaPay-Signature')
    
    if not validate_webhook_data(data):
        return jsonify({'error': 'Invalid data'}), 400
    
    if not WebhookValidator.verify_oxapay(request.get_data(as_text=True), signature, config.OXAPAY_API_KEY):
        return jsonify({'error': 'Invalid signature'}), 401
    
    if data.get('status') in ['Paid', 'Completed']:
        order_id = data.get('orderId')
        process_successful_payment(order_id)
        
    return jsonify({'status': 'ok'}), 200

@app.route(f'/webhook/cryptomus/{config.WEBHOOK_SECRET}', methods=['POST'])
def webhook_cryptomus():
    """Webhook seguro para Cryptomus con validaci√≥n MD5 + IP whitelist"""
    if request.remote_addr != '91.227.144.54':
        logger.warning(f"Cryptomus: Unauthorized IP {request.remote_addr}")
        return jsonify({'error': 'Unauthorized IP'}), 403
        
    data = request.json
    if not validate_webhook_data(data):
        return jsonify({'error': 'Invalid data'}), 400
    
    if not WebhookValidator.verify_cryptomus(data, config.CRYPTOMUS_API_KEY):
        return jsonify({'error': 'Invalid signature'}), 401
    
    if data.get('status') in ['paid', 'paid_over']:
        order_id = data.get('order_id')
        process_successful_payment(order_id)
        
    return jsonify({'status': 'ok'}), 200



@app.route(f'/webhook/nowpayments/{config.WEBHOOK_SECRET}', methods=['POST'])
def webhook_nowpayments():
    """Webhook seguro para NOWPayments con validaci√≥n HMAC-SHA512"""
    data = request.json
    signature = request.headers.get('x-nowpayments-sig')
    
    if not validate_webhook_data(data):
        return jsonify({'error': 'Invalid data'}), 400
    
    if not WebhookValidator.verify_nowpayments(request.get_data(as_text=True), signature, config.NOWPAYMENTS_IPN_SECRET):
        return jsonify({'error': 'Invalid signature'}), 401
    
    if data.get('payment_status') == 'finished':
        order_id = data.get('order_id')
        process_successful_payment(order_id)
    
    return jsonify({'status': 'ok'}), 200



@app.route('/pay/<int:user_id>', methods=['GET'])
def pay_page(user_id):
    """P√°gina p√∫blica de pago para usuarios externos (fuera de Telegram)"""
    # Link de Deep Linking para abrir el bot y pagar con tarjeta
    # Reemplaza 'VStrike1690_Bot' con la variable de config si est√° disponible
    bot_username = config.TELEGRAM_BOT_USERNAME.replace('@', '')
    telegram_pay_link = f"https://t.me/{bot_username}?start=pay"

    html = f"""
    <!DOCTYPE html>
    <html lang="es">
    <head>
        <meta charset="UTF-8">
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        <title>Pagar VIP V-Strike</title>
        <script src="https://cdn.tailwindcss.com"></script>
    </head>
    <body class="bg-gray-900 text-white min-h-screen flex items-center justify-center font-sans p-4">
        <div class="bg-gray-800 p-6 md:p-8 rounded-xl shadow-2xl w-full max-w-sm border border-gray-700 text-center">
            <h1 class="text-3xl font-bold mb-2 text-blue-400">V-Strike VIP</h1>
            <p class="text-gray-400 mb-8">Acceso vitalicio al canal premium</p>

            <div class="bg-gray-700/50 p-4 rounded-lg mb-8">
                <p class="text-sm text-gray-400">Total a pagar</p>
                <p class="text-4xl font-bold text-white">${config.VIP_PRICE_USD} <span class="text-lg text-gray-500">USD</span></p>
            </div>

            <div class="space-y-4">
                <!-- Opci√≥n 1: Tarjeta v√≠a Telegram (Stars) -->
                <a href="{telegram_pay_link}" class="block w-full bg-indigo-600 hover:bg-indigo-500 text-white font-bold py-4 px-6 rounded-lg transition transform hover:scale-105 shadow-lg flex items-center justify-center gap-2 no-underline">
                    <span>üí≥</span> Pagar con Tarjeta
                    <span class="text-xs font-normal opacity-75">(V√≠a Telegram)</span>
                </a>

                <div class="relative flex py-2 items-center">
                    <div class="flex-grow border-t border-gray-600"></div>
                    <span class="flex-shrink-0 mx-4 text-gray-500 text-xs">O criptomonedas</span>
                    <div class="flex-grow border-t border-gray-600"></div>
                </div>

                <!-- Opci√≥n 2: Cripto NOWPayments -->
                <form action="/pay/process" method="POST">
                    <input type="hidden" name="user_id" value="{user_id}">
                    <button type="submit" class="w-full bg-gray-700 hover:bg-gray-600 text-white font-bold py-3 px-6 rounded-lg transition border border-gray-600 flex items-center justify-center gap-2">
                        <span>ü™ô</span> Pagar con Cripto
                    </button>
                </form>
            </div>
            
            <p class="mt-6 text-xs text-gray-500">
                El acceso se activa autom√°ticamente para el ID: {user_id}
            </p>
        </div>
    </body>
    </html>
    """
    return render_template_string(html)

@app.route('/pay/process', methods=['POST'])
def pay_process():
    """Procesa el clic en el bot√≥n de pago"""
    user_id = request.form.get('user_id')
    if not user_id:
        return "Error: User ID missing", 400
    
    # Generar orden
    order_id = str(uuid.uuid4())
    amount = config.VIP_PRICE_USD
    
    # Generar link NOWPayments
    result = generate_payment_link("NOWPayments", amount, order_id, int(user_id))
    
    if result:
        # Registrar transacci√≥n
        db.create_transaction(order_id, int(user_id), amount, "NOWPayments", "Web Direct")
        
        # Redirigir a la factura de NOWPayments
        url = result.get('invoice_url')
        if url:
             from flask import redirect
             return redirect(url)
    
    return "Error generando el pago. Intenta de nuevo m√°s tarde."


@app.route('/generar-pago', methods=['GET', 'POST'])
def generar_pago_web():
    """Interfaz Web para Generar Pagos"""
    link_generado = None
    error = None
    
    if request.method == 'POST':
        method = request.form.get('method')
        amount = float(request.form.get('amount'))
        user_id = int(request.form.get('user_id'))
        order_id = str(uuid.uuid4())
        
        # Generar enlace
        result = generate_payment_link(method, amount, order_id, user_id)
        
        if result:
            db.create_transaction(order_id, user_id, amount, method, "Web Generator")
            link_generado = result.get('payLink') or result.get('url') or result.get('invoice_url')
        else:
            error = "Error al generar el enlace. Verifica los logs."

    # HTML Simple con TailwindCSS (CDN)
    html = """
    <!DOCTYPE html>
    <html lang="es">
    <head>
        <meta charset="UTF-8">
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        <title>Generador de Pagos V-Strike</title>
        <script src="https://cdn.tailwindcss.com"></script>
    </head>
    <body class="bg-gray-900 text-white min-h-screen flex items-center justify-center">
        <div class="bg-gray-800 p-8 rounded-lg shadow-lg w-full max-w-md border border-gray-700">
            <h1 class="text-2xl font-bold mb-6 text-center text-blue-400">Generar Enlace de Pago</h1>
            
            {% if link_generado %}
                <div class="bg-green-900/50 border border-green-500 text-green-200 p-4 rounded mb-6">
                    <p class="font-bold">¬°Enlace Generado!</p>
                    <a href="{{ link_generado }}" target="_blank" class="block mt-2 text-blue-300 underline break-all hover:text-blue-100">
                        {{ link_generado }}
                    </a>
                    <a href="/generar-pago" class="block mt-4 text-sm text-center text-gray-400 hover:text-white">Generar otro</a>
                </div>
            {% else %}
                {% if error %}
                    <div class="bg-red-900/50 border border-red-500 text-red-200 p-3 rounded mb-4">{{ error }}</div>
                {% endif %}
                
                <form method="POST" class="space-y-4">
                    <div>
                        <label class="block text-sm font-medium mb-1">Pasarela de Pago (Aceptan Tarjeta)</label>
                        <select name="method" class="w-full bg-gray-700 border border-gray-600 rounded p-2 focus:outline-none focus:border-blue-500">
                            <option value="OxaPay">OxaPay (Recomendado Tarjetas)</option>
                            <option value="Cryptomus">Cryptomus (Tarjeta + Cripto)</option>
                            <option value="NOWPayments">NOWPayments</option>
                        </select>
                    </div>
                    
                    <div>
                        <label class="block text-sm font-medium mb-1">Monto (USD)</label>
                        <input type="number" name="amount" step="0.01" value="10.00" class="w-full bg-gray-700 border border-gray-600 rounded p-2 focus:outline-none focus:border-blue-500">
                    </div>
                    
                    <div>
                        <label class="block text-sm font-medium mb-1">ID Usuario Telegram</label>
                        <input type="number" name="user_id" placeholder="Ej: 715520483" required class="w-full bg-gray-700 border border-gray-600 rounded p-2 focus:outline-none focus:border-blue-500">
                    </div>
                    
                    <button type="submit" class="w-full bg-blue-600 hover:bg-blue-500 text-white font-bold py-2 px-4 rounded transition">
                        Generar Enlace
                    </button>
                </form>
            {% endif %}
        </div>
    </body>
    </html>
    """
    return render_template_string(html, link_generado=link_generado, error=error)

def process_successful_payment(order_id):
    """L√≥gica com√∫n para procesar pagos exitosos"""
    try:
        with db.get_connection() as conn:
            c = conn.cursor()
            c.execute("SELECT user_id FROM transactions WHERE tx_id = ?", (order_id,))
            result = c.fetchone()
            
            if result:
                user_id = result[0]
                db.update_transaction_status(order_id, 'completed')
                send_payment_notification(order_id, user_id)
                logger.info(f"Payment processed and notification queued for {order_id}")
            else:
                logger.error(f"Order {order_id} not found in database")
    except Exception as e:
        logger.error(f"Error processing success payment: {e}")

# --- Bot Handlers ---

async def start(update: Update, context: ContextTypes.DEFAULT_TYPE):
    user = update.effective_user
    db.add_user(user.id)
    
    # Manejar deep linking (ej: /start pay)
    if context.args and context.args[0] == 'pay':
        await pay(update, context)
        return

    await update.message.reply_text(
        f"Hola {user.first_name}, bienvenido a V-Strike CRM.\n"
        "Usa /pay para obtener tu acceso VIP.\n"
        "Usa /status para ver tu estado."
    )

async def status_command(update: Update, context: ContextTypes.DEFAULT_TYPE):
    user_id = update.effective_user.id
    user = db.get_user(user_id)
    # user tuple index depends on schema, usually (id, join_date, last_int, is_vip, ...)
    # is_vip is at index 3 in current schema
    is_vip = user[3] if user and len(user) > 3 else False
    
    status_text = "üåü VIP Activo" if is_vip else "‚ùå Usuario Gratuito"
    await update.message.reply_text(f"Tu Estado: {status_text}")



async def pay(update: Update, context: ContextTypes.DEFAULT_TYPE):
    keyboard = [
        [InlineKeyboardButton("‚≠ê Estrellas (R√°pido)", callback_data='pay_Stars')],
        [InlineKeyboardButton("ü™ô Cripto / Tarjeta (NOWPayments)", callback_data='pay_NOWPayments')],
    ]
    reply_markup = InlineKeyboardMarkup(keyboard)
    await update.message.reply_text(f"Elige tu m√©todo de pago (Precio: ${config.VIP_PRICE_USD} USD):", reply_markup=reply_markup)

async def button_handler(update: Update, context: ContextTypes.DEFAULT_TYPE):
    query = update.callback_query
    await query.answer()
    
    method = query.data.split('_')[1]
    user_id = query.from_user.id
    order_id = str(uuid.uuid4())
    
    if method == "Stars":
        try:
            prices = [LabeledPrice("VIP Access", config.STARS_PRICE)]
            await context.bot.send_invoice(
                chat_id=user_id,
                title="V-Strike VIP",
                description="Acceso exclusivo al canal VIP",
                payload=order_id,
                provider_token="", # Empty for Stars
                currency="XTR",
                prices=prices
            )
            db.create_transaction(order_id, user_id, config.VIP_PRICE_USD, "Stars", "Telegram Stars")
        except Exception as e:
            logger.error(f"Error sending invoice: {e}")
            await query.edit_message_text("Error al generar factura de Stars.")
            
    else:
        # Generar link para otros m√©todos (NOWPayments, etc)
        await query.edit_message_text(f"Generando enlace de pago para {method}...")
        
        # payments.generate_payment_link maneja la l√≥gica
        link_data = generate_payment_link(method, config.VIP_PRICE_USD, order_id, user_id) 
        
        if link_data:
            # Compatibilidad con diferentes respuestas de gateways
            url = link_data.get('payLink') or link_data.get('url') or link_data.get('invoice_url')
            
            db.create_transaction(order_id, user_id, config.VIP_PRICE_USD, method, "External Gateway")
            
            keyboard = [[InlineKeyboardButton("üîó Pagar Ahora", url=url)]]
            reply_markup = InlineKeyboardMarkup(keyboard)
            
            await query.edit_message_text(
                f"Has elegido **{method}**.\n"
                f"Usa el bot√≥n abajo para completar el pago.\n"
                "El enlace expira en 30 minutos.",
                reply_markup=reply_markup,
                parse_mode='Markdown'
            )
        else:
            await query.edit_message_text(f"Error generando el enlace. Verifica los logs.")




async def pre_checkout_handler(update: Update, context: ContextTypes.DEFAULT_TYPE):
    query = update.pre_checkout_query
    logger.info(f"Received pre-checkout query: {query.id} from user {query.from_user.id} for payload {query.invoice_payload}")
    try:
        await query.answer(ok=True)
        logger.info(f"Answered pre-checkout query {query.id} with ok=True")
    except Exception as e:
        logger.error(f"Error answering pre-checkout query: {e}")


async def successful_payment_handler(update: Update, context: ContextTypes.DEFAULT_TYPE):
    payment = update.message.successful_payment
    order_id = payment.invoice_payload
    user_id = update.effective_user.id
    
    db.update_transaction_status(order_id, 'completed')
    await update.message.reply_text("¬°Pago con Stars recibido! Ya eres VIP.")
    await context.bot.send_message(chat_id=config.ADMIN_ID, text=f"üí∞ Nueva venta v√≠a Stars!\nUsuario: {user_id}")

async def dashboard(update: Update, context: ContextTypes.DEFAULT_TYPE):
    if update.effective_user.id != config.ADMIN_ID:
        return
    
    stats = db.get_daily_stats()
    msg = (
        f"üìä **Dashboard V-Strike**\n\n"
        f"Ventas Hoy: {stats['daily_sales']}\n"
        f"Ingresos Totales: ${stats['total_revenue']:.2f}\n"
        f"M√©todo Favorito: {stats['popular_method']}\n"
        f"Total VIPs: {stats['total_vip_users']}"
    )
    await update.message.reply_text(msg, parse_mode='Markdown')

async def error_handler(update: object, context: ContextTypes.DEFAULT_TYPE) -> None:
    """Log the error and send a telegram message to notify the developer."""
    logger.error(msg="Exception while handling an update:", exc_info=context.error)

    # Solo notificar al admin si es algo cr√≠tico, para evitar spam
    if update and update.effective_user and update.effective_user.id == config.ADMIN_ID:
         await context.bot.send_message(chat_id=config.ADMIN_ID, text=f"‚ö†Ô∏è Error: {context.error}")

# --- Main Runtime ---

def run_flask():
    logger.info(f"Starting Flask server on port {config.PORT}")
    app.run(host='0.0.0.0', port=config.PORT, debug=False, use_reloader=False, threaded=True)

async def main():
    if not config.validate_config():
        return

    # Initialize Database
    db.init_db()

    # Build Application
    request_kwargs = HTTPXRequest(
        connect_timeout=60.0,
        read_timeout=60.0,
        write_timeout=60.0,
        pool_timeout=60.0,
    )
    application = Application.builder().token(config.TELEGRAM_BOT_TOKEN).request(request_kwargs).build()
    
    # Add Error Handler
    application.add_error_handler(error_handler)
    
    # Add Handlers
    application.add_handler(CommandHandler("start", start))
    application.add_handler(CommandHandler("pay", pay))
    application.add_handler(CommandHandler("status", status_command))
    application.add_handler(CommandHandler("dashboard", dashboard))
    application.add_handler(CallbackQueryHandler(button_handler))
    application.add_handler(PreCheckoutQueryHandler(pre_checkout_handler))
    application.add_handler(MessageHandler(filters.SUCCESSFUL_PAYMENT, successful_payment_handler))

    # Start Flask in background
    flask_thread = threading.Thread(target=run_flask, daemon=True)
    flask_thread.start()

    # Start Bridge Task
    asyncio.create_task(bridge_task(application.bot))

    logger.info("Bot started...")
    

    async with application:
        await application.initialize()
        await application.start()
        logger.info("Deleting webhook to ensure polling works...")

        await application.bot.delete_webhook(drop_pending_updates=True)
        await application.updater.start_polling()
        
        # Keep running until interrupted
        logger.info("Bot is polling...")
        try:
            # Mantener el script vivo y manejar interrupciones limpiamente
            stop_signal = asyncio.Event()
            await stop_signal.wait()
        except (KeyboardInterrupt, SystemExit):
            pass
        finally:
            await application.stop()
            await application.shutdown()

if __name__ == "__main__":
    try:
        asyncio.run(main())
    except Exception as e:
        logger.critical(f"Fatal error in main loop: {e}")
